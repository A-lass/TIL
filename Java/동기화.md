# 동기화 (Synchronization)
### 스레드 동기화
* 한 스레드가 진행 중인 작업을 다른 스레드가 간섭하지 못하도록 막는 것
### 임계 영역 (Critical Section)
* 공유 데이터를 사용하는 코드 영역
### 락 (Lock)
* 임계 영역에 접근하는 스레드들 간의 경쟁 상태를 조절하고 동기화를 제공하는 메커니즘
### 경쟁 상태 (Race Condition)
* 여러 스레드가 락을 얻기 위해 서로 경쟁하는 상태

<br/><br/>

# `Synchronized`를 이용한 동기화
### 1. 메서드 전체를 임계 영역으로 지정
``` java
    public synchronized void foo () {
        // ...
    }
```
* 메서드 전체가 임계 영역이 된다.
* 스레드는 `synchronized` 메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 락을 얻어 작업을 수행하다가 메서드가 종료되면 락을 반환한다.

### 2. 특정한 영역을 임계 영역으로 지정
``` java
    synchronized (Object o) {
        // ...
    }
```
* 해당 블록의 영역 안으로 들어가면서부터 스레드는 지정된 객체의 락을 얻게 되고, 이 블럭을 벗어나면 락을 반납한다.
* `()` 안에 들어가는 참조 변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다.

<br/><br/>

* 두 방법 모두 락의 획득과 반납이 자동적으로 이루어지므로 임계 영역만 설정해주면 된다.
* 모든 객체는 락을 하나씩 가지고 있으며, 해당 객체의 락을 가지고 있는 스레드만 임계 영역의 코드를 수행할 수 있다.
* 임계 영역은 멀티스레드 프로그램의 성능을 좌우한다.
    -> 가능하면 메서드 전체에 락을 거는 것보다 `synchronized` 블럭으로 임계 영역을 최소화하는게 좋다.

<br/><br/>

# `wait()`과 `notify()`
* `Synchronized`로 동기화를 하면 특정 스레드가 객체의 락을 가진 상태로 오랜 시간을 보내는 경우가 발생한다. 이를 개선하기 위해 고안된 것이 `wait()`과 `notify()`다.
* 동작 방식
    *  동기화된 임계 영역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니라면 `wait()`을 호출하여 스레드가 락을 반납하고 기다리게 한다.
    * 다른 스레드가 락을 얻어 해당 객체에 대한 작업을 수행한다.
    * 나중에 작업을 진행할 수 있는 상황이 되면 `notify()`를 호출하여 작업을 중단했던 스레드가 다시 락을 얻어 작업을 중단했던 스레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.
* `Object` 에 정의되어 있다.
* 동기화 블록(`synchronized` 블록) 내에서만 사용할 수 있다.
* 보다 효율적인 동기화를 가능하게 한다.
* `notify()`가 호출되면 해당 객체의 `waiting pool`에 대기 중인 모든 스레드 중 임의의 스레드만 통지 받음.
* `notifyAll()`은 `waiting pool`에 있는 모든 스레드에게 통보를 하지만 락을 얻을 수 있는 스레드는 하나이기 때문에 나머지는 다시 락을 기다려야함.

### 문제점
1) 기아 현상
    * 통지받아야 하는 스레드가 계속 통지받지 못하고 오랫동안 기다리게 되는 현상
    * `notify()` 대신 `notifyAll()`로 해결할 수 있지만 불필요한 락 경쟁을 하게 됨
2) 경쟁 상태
    * `notifyAll()`로 인해 불필요한 락 경쟁을 하게 됨

### 해결방안
* `Lock`과 `Condition`을 이용하면 `wait()`과 `notify()`로는 불가능한 선별적 통지 가능

<br/><br/>

# `Lock`과 `Condition`을 이용한 동기화
* `JDK 1.5`에서 추가된 `java.util.concurrent.lock` 패키지에서 제공

### `ReentrantLock`
* 재진입이 가능한 락으로 가장 일반적인 락
* 특정 조건에서 락을 풀고 나중에 다시 락을 얻고 임계 영역으로 들어와서 이후의 작업을 실행할 수 있게 함
* 위에서 언급한 락들이 `ReentrantLock`

### `ReentrantReadWriteLock`
* 읽기에는 공유적이고, 쓰기에는 배타적인 락
* 읽기 락이 걸려있으면 다른 스레드가 읽기 락을 중복해서 걸고 읽기 작업을 수행할 수 있다.
    -> 읽기는 내용을 변경하지 않으므로 동시에 여러 스레드가 읽어도 문제 X
* 읽기 락이 걸린 상태에서 쓰기 락을 거는 것은 허용되지 않는다. (반대의 경우도 마찬가지)

### `StampedLock`
* `JDK 1.8`부터 추가되었으며, 다른 락과 달리 `Lock`인터페이스를 구현하지 않음
* `ReentrantReadWriteLock` + 낙관적 읽기 락(Optimistic Reading Lock)
* 읽기 락이 걸려있으면 쓰기 락을 얻기 위해 읽기 락이 풀릴 때까지 기다려야 하지만 낙관적 읽기 락은 쓰기 락에 의해 바로 풀린다.
    -> 낙관적 읽기에 실패하면, 읽기 락을 얻어서 다시 읽어와야 한다.
    -> 무조건 읽기 락을 걸지 않고, 쓰기와 읽기가 충돌할 때만 쓰기가 끝난 후에 읽기 락을 거는 것이다.

<br/><br/>

### Ref
[남궁성, 『Java의 정석』, 도우출판, 2016.](https://www.yes24.com/Product/Goods/24259565)
